// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

import app from '../../../app';
import FauxtonAPI from '../../../core/api';
import ActionTypes from './actiontypes';


/**
 * Initializes the bookmark manager.
 * This function loads the available bookmarks from a persistent storage
 * and notifies the store to update it's internal datastructures.
 * The method also checks for an available 'page' parameter in the current URL
 * and adjusts the displayed page of bookmarks if present.
 */
function initialize () {
  let bookmarks = {};
  if (localStorage.getItem('__bookmarks')) {
    bookmarks = JSON.parse(localStorage.getItem('__bookmarks'));
  }

  const params = app.getParams();
  let page = params.page ? parseInt(params.page, 10) : 1;

  FauxtonAPI.dispatch({
    type: ActionTypes.BOOKMARK_INIT,
    options: {
      bookmarks: bookmarks,
      page: page - 1
    }
  });
}

/**
 * Sets the bookmark that is currently subject of being edited
 * @param The bookmark to be edited
 */
function focusBookmark (bookmark) {
  FauxtonAPI.dispatch({
    type: ActionTypes.BOOKMARK_FOCUS_BOOKMARK,
    options: {
      bookmark: bookmark
    }
  });
}

/**
 * Unsets the bookmark of being a subject to editing
 */
function clearFocusedBookmark () {
  FauxtonAPI.dispatch({
    type: ActionTypes.BOOKMARK_FOCUS_BOOKMARK,
    options: {
      bookmark: undefined
    }
  });
}


/**
 * Deletes the bookmark from the map of available bookmarks
 * @param The bookmark to be deleted
 */
function deleteBookmark (bookmark) {
  let bookmarks = {};
  if (localStorage.getItem('__bookmarks')) {
    bookmarks = JSON.parse(localStorage.getItem('__bookmarks'));
  }

  if (bookmarks[bookmark.id]) {
    delete bookmarks[bookmark.id];
  }
  localStorage.setItem('__bookmarks', JSON.stringify(bookmarks));

  FauxtonAPI.dispatch({
    type: ActionTypes.BOOKMARK_UPDATE_BOOKMARKS,
    options: {
      bookmarks: bookmarks
    }
  });
}

/**
 * Removes a set of bookmarks given their id's
 * @param An array of id's containing the bookmarks to be removed
 */
function bulkRemove (removeables) {

  let bookmarks = {};
  if (localStorage.getItem('__bookmarks')) {
    bookmarks = JSON.parse(localStorage.getItem('__bookmarks'));
  }

  for (let i in bookmarks) {
    if (removeables.indexOf(i) > -1) {
      delete bookmarks[i];
    }
  }

  localStorage.setItem('__bookmarks', JSON.stringify(bookmarks));

  FauxtonAPI.dispatch({
    type: ActionTypes.BOOKMARK_UPDATE_BOOKMARKS,
    options: {
      bookmarks: bookmarks
    }
  });
}

/**
 * Saves the bookmark in a repository and triggers an update on the store
 * @param The bookmark to be stored
 */
function saveBookmark (bookmark) {
  if (!bookmark.id || bookmark.id.length === 0) {
    bookmark.id = _uuid();
  }

  // For now we use local storage and switch to couchdb later on
  let bookmarks = {};
  if (localStorage.getItem('__bookmarks')) {
     bookmarks = JSON.parse(localStorage.getItem('__bookmarks'));
  }
  bookmarks[bookmark.id] = bookmark;
  localStorage.setItem('__bookmarks', JSON.stringify(bookmarks));

  FauxtonAPI.dispatch({
    type: ActionTypes.BOOKMARK_UPDATE_BOOKMARKS,
    options: {
      bookmarks: bookmarks
    }
  });
  return true;
}


/**
 * Sets the term to be used for filtering the results of the current
 * displayed table of bookmarks.
 * @param The value to be used for filtering the results (e.g. The search term)
 */
function setFilter (value) {
  FauxtonAPI.dispatch({
    type: ActionTypes.BOOKMARK_UPDATE_FILTER,
    options: {
      term: value
    }
  });
}

/**
 * Method that provides a 'unique' id.
 * The id is generated by taking the current timestamp suffixed with
 * a random value between 0 and 100.000.
 */
function _uuid() {

  let t = new Date().getTime();
  t += Math.floor(Math.random() * 100000);
  return t;
}

export default {
  initialize,
  focusBookmark,
  clearFocusedBookmark,
  deleteBookmark,
  saveBookmark,
  bulkRemove,
  setFilter
};
